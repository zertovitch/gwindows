
-- This header comes from RC.y (at bottom)

with RC_Tokens, RC_Shift_Reduce, RC_Goto, RC_Help, RC_IO;
use  RC_Tokens, RC_Shift_Reduce, RC_Goto, RC_Help;

with RC_DFA, YYroutines, YYerror;
use  RC_DFA, YYroutines;

with Ada.Text_IO;                       use Ada.Text_IO;
with Text_IO; -- for compat.

--  with Ada.Characters.Handling;           use Ada.Characters.Handling;
with Ada.Strings.Fixed;                 use Ada.Strings, Ada.Strings.Fixed;
with Ada.Strings.Unbounded;             use Ada.Strings.Unbounded;

with Interfaces;                        use Interfaces;

with GWindows.Static_Controls,
     GWindows.Common_Controls;

-- Header end.

--  Warning: This file is automatically generated by AYACC.
--           It is useless to modify it. Change the ".Y" & ".L" files instead.

with YY_Sizes;
-- ^ 14-Jan-2006 (GdM): configurable sizes instead of hard-coded
--   ones in AYACC's output

procedure YYParse is

   -- Rename User Defined Packages to Internal Names.
    package yy_goto_tables         renames
      Rc_Goto;
    package yy_shift_reduce_tables renames
      Rc_Shift_Reduce;
    package yy_tokens              renames
      Rc_Tokens;
    package yy_io                  renames -- (+GdM 2008)
      Rc_IO;

   use yy_tokens, yy_goto_tables, yy_shift_reduce_tables;

   procedure yyerrok;
   procedure yyclearin;


   package yy is

       -- the size of the value and state stacks
       --  Affects error 'Stack size exceeded on state_stack'
       stack_size : constant Natural := yy_sizes.stack_size; -- was 300, then 8192

       -- subtype rule         is Natural;
       subtype parse_state  is Natural;
       -- subtype nonterminal  is Integer;

       -- encryption constants
       default           : constant := -1;
       first_shift_entry : constant :=  0;
       accept_code       : constant := -3001;
       error_code        : constant := -3000;

       -- stack data used by the parser
       tos                : Natural := 0;
       value_stack        : array(0..stack_size) of yy_tokens.YYSType;
       state_stack        : array(0..stack_size) of parse_state;

       -- current input symbol and action the parser is on
       action             : Integer;
       rule_id            : Rule;
       input_symbol       : yy_tokens.Token:= Error;


       -- error recovery flag
       error_flag : Natural := 0;
          -- indicates  3 - (number of valid shifts after an error occurs)

       look_ahead : Boolean := True;
       index      : Integer;

       -- Is Debugging option on or off
       debug : constant Boolean := FALSE;

    end yy;


    function goto_state
      (state : yy.parse_state;
       sym   : Nonterminal) return yy.parse_state;

    function parse_action
      (state : yy.parse_state;
       t     : yy_tokens.Token) return Integer;

    pragma inline(goto_state, parse_action);


    function goto_state(state : yy.parse_state;
                        sym   : Nonterminal) return yy.parse_state is
        index : Integer;
    begin
        index := goto_offset(state);
        while Integer (Goto_Matrix(index).nonterm) /= sym loop
            index := index + 1;
        end loop;
        return Integer (Goto_Matrix(index).newstate);
    end goto_state;


    function parse_action(state : yy.parse_state;
                          t     : yy_tokens.token) return Integer is
        index      : Integer;
        tok_pos    : Integer;
        default    : constant Integer := -1;
    begin
        tok_pos := yy_tokens.token'pos(t);
        index   := Shift_Reduce_Offset(state);
        while Integer (Shift_Reduce_Matrix(index).t) /= tok_pos and then
              Integer (Shift_Reduce_Matrix(index).t) /= default
        loop
            index := index + 1;
        end loop;
        return Integer (shift_reduce_matrix(index).act);
    end parse_action;

-- error recovery stuff

    procedure Handle_Error is
      temp_action : Integer;
    begin

      if yy.error_flag = 3 then  --  no shift yet, clobber input.
      if yy.debug then
          Text_IO.Put_Line("  -- Ayacc.YYParse: Error Recovery Clobbers " &
                   yy_tokens.token'Image(yy.input_symbol));
      end if;
        if yy.input_symbol = yy_tokens.end_of_input then  --  don't discard,
        if yy.debug then
            Text_IO.Put_Line("  -- Ayacc.YYParse: Can't discard END_OF_INPUT, quitting...");
        end if;
        raise yy_tokens.Syntax_Error;
        end if;

        yy.look_ahead := True;   --  get next token
        return;                  --  and try again...
    end if;

    if yy.error_flag = 0 then -- brand new error
        if yy_io.Input_Line > 1 then
            yyerror("Syntax Error at line" & Text_IO.Count'Image(yy_io.Input_Line));
        else
            yyerror("Syntax Error at line 1 (or possibly later and the AFLex -E option was omitted).");
        end if;
    end if;

    yy.error_flag := 3;

    -- find state on stack where error is a valid shift --

    if yy.debug then
        Text_IO.Put_Line("  -- Ayacc.YYParse: Looking for state with error as valid shift");
    end if;

    loop
        if yy.debug then
          Text_IO.Put_Line("  -- Ayacc.YYParse: Examining State " &
               yy.parse_state'Image(yy.state_stack(yy.tos)));
        end if;
        temp_action := parse_action(yy.state_stack(yy.tos), error);

            if temp_action >= yy.first_shift_entry then
                if yy.tos = yy.stack_size then
                    Text_IO.Put_Line("  -- Ayacc.YYParse: Stack size exceeded on state_stack");
                    raise yy_Tokens.syntax_error;
                end if;
                yy.tos := yy.tos + 1;
                yy.state_stack(yy.tos) := temp_action;
                exit;
            end if;

        Decrement_Stack_Pointer :
        begin
          yy.tos := yy.tos - 1;
        exception
          when Constraint_Error =>
            yy.tos := 0;
        end Decrement_Stack_Pointer;

        if yy.tos = 0 then
          if yy.debug then
            Text_IO.Put_Line("  -- Ayacc.YYParse: Error recovery popped entire stack, aborting...");
          end if;
          raise yy_tokens.syntax_error;
        end if;
    end loop;

    if yy.debug then
        Text_IO.Put_Line("  -- Ayacc.YYParse: Shifted error token in state " &
              yy.parse_state'Image(yy.state_stack(yy.tos)));
    end if;

    end Handle_Error;

   --  Print debugging information for a shift operation
   procedure Shift_Debug (state_id: yy.parse_state; lexeme: yy_tokens.token) is
   begin
       Text_IO.Put_Line("  -- Ayacc.YYParse: Shift "& yy.parse_state'Image(state_id)&" on input symbol "&
               yy_tokens.token'Image(lexeme) );
   end Shift_Debug;

   --  Print debugging information for a reduce operation
   procedure Reduce_Debug (rule_id: rule; state_id: yy.parse_state) is
   begin
       Text_IO.Put_Line("  -- Ayacc.YYParse: Reduce by rule "&rule'Image(rule_id)&" goto state "&
               yy.parse_state'Image(state_id));
   end Reduce_Debug;

   -- make the parser believe that 3 valid shifts have occured.
   -- used for error recovery.
   procedure yyerrok is
   begin
       yy.error_flag := 0;
   end yyerrok;

   -- called to clear input symbol that caused an error.
   procedure yyclearin is
   begin
       -- yy.input_symbol := yylex;
       yy.look_ahead := True;
   end yyclearin;


begin
    -- initialize by pushing state 0 and getting the first input symbol
    yy.state_stack(yy.tos) := 0;


    loop

        yy.index := Shift_Reduce_Offset(yy.state_stack(yy.tos));
        if Integer (shift_reduce_matrix(yy.index).t) = yy.default then
            yy.action := Integer (shift_reduce_matrix(yy.index).act);
        else
            if yy.look_ahead then
                yy.look_ahead   := False;

                yy.input_symbol := yylex;
            end if;
            yy.action :=
             parse_action(yy.state_stack(yy.tos), yy.input_symbol);
        end if;


        if yy.action >= yy.first_shift_entry then  -- SHIFT

            if yy.debug then
              Shift_Debug (yy.action, yy.input_symbol);
            end if;

            --  Enter new state
            if yy.tos = yy.stack_size then
                Text_IO.Put_Line(" Stack size exceeded on state_stack");
                raise yy_Tokens.syntax_error;
            end if;
            yy.tos := yy.tos + 1;
            yy.state_stack(yy.tos) := yy.action;
              yy.value_stack(yy.tos) := YYLVal;

        if yy.error_flag > 0 then  --  Indicate a valid shift
          yy.error_flag := yy.error_flag - 1;
        end if;

            --  Advance lookahead
            yy.look_ahead := True;

        elsif yy.action = yy.error_code then       -- ERROR

            Handle_Error;

        elsif yy.action = yy.accept_code then
            if yy.debug then
                Text_IO.Put_Line("  -- Ayacc.YYParse: Accepting Grammar...");
            end if;
            exit;

        else -- Reduce Action

            -- Convert action into a rule
            yy.rule_id  := -1 * yy.action;

            -- Execute User Action
            -- user_action(yy.rule_id);


                case yy.rule_id is

when 1 => -- #line 223
RC_Help.YY_ACCEPT;

when 2 => -- #line 224
RC_Help.YY_ABORT;

when 25 => -- #line 264
 style_switch(simple_border):= True;

when 26 => -- #line 266
 style_switch(simple_border):= False;

when 27 => -- #line 268
 style_switch(hidden):= False;

when 28 => -- #line 270
 style_switch(hidden):= True;

when 32 => -- #line 275
 style_switch(sys_menu):= True;

when 37 => -- #line 281
 style_switch(disabled):= True;

when 47 => -- #line 299
 if anonymous_item then
                   anonymous_dialog_counter:=
                     anonymous_dialog_counter+1;
                   last_dialog_ident:= U("Dialog_" &
                     Trim(Integer'Image(anonymous_dialog_counter),both));
                 else
                   last_dialog_ident:= last_ident;
                 end if;

when 48 => -- #line 309

                 Open_if_separate(S(last_dialog_ident));
                 Ada_Put_Line(to_spec,
                   "  type " & S(last_dialog_ident) &
                   "_Type is new Window_Type with record"
                 );
                 Ada_New_Line(to_spec);
                 Ada_New_Line(to_body);
                 last_caption := U("""""");
                 style_switch := (others => False);  --  Reset all style switches
                 static_counter := 0;

when 49 => -- #line 324
last_dialog_rect:= last_rect;

when 50 => -- #line 327

                 last_dialog_caption := last_caption;
                 dialog_style_switch := style_switch;
                 Ada_Proc_Dialog(
                    to_body,
                    S(last_dialog_ident) & "_Type",
                    S(last_dialog_caption)
                 );

when 51 => -- #line 337
empty_dialog_record := True;

when 52 => -- #line 340
 Ada_Proc_Dialog(
                    to_spec,
                    S(last_dialog_ident) & "_Type",
                    S(last_dialog_caption)
                 );
                 Ada_Put_Line(to_spec, ";");
                 Ada_New_Line(to_spec);
                 Ada_Put_Line(to_body,
                   "  end Create_Contents;  --  " &
                   S(last_dialog_ident) & "_Type" );
                 Close_if_separate(S(last_dialog_ident));

when 65 => -- #line 380
style_switch(shell_font) := True;

when 85 => -- #line 419
style_switch (shell_font) := True;

when 86 => -- #line 420
style_switch (shell_font) := True;

when 87 => -- #line 421
style_switch (shell_font) := True;

when 100 => -- #line 450
last_caption := U (YYText);

when 102 => -- #line 454

              style_switch:= (others => False); -- Reset all style switches
              last_text:= U("""""");

when 105 => -- #line 463
empty_dialog_record := False;

when 107 => -- #line 465
empty_dialog_record := False;

when 108 => -- #line 466
empty_dialog_record := False;

when 109 => -- #line 467
empty_dialog_record := False;

when 110 => -- #line 468
empty_dialog_record := False;

when 111 => -- #line 469
empty_dialog_record := False;

when 112 => -- #line 470
empty_dialog_record := False;

when 113 => -- #line 471
empty_dialog_record := False;

when 114 => -- #line 472
empty_dialog_record := False;

when 115 => -- #line 482
control := unknown;
                Reset_control_styles;

when 116 => -- #line 486
last_control_text := U(YYText);

when 117 => -- #line 490
Insert_last_symbol;

when 118 => -- #line 494
last_class := U(YYText);

when 119 => -- #line 500
Ada_untyped_control;

when 123 => -- #line 511
 Identify_control_class (YYText);

when 125 => -- #line 525
 control:= date_time;

when 128 => -- #line 530
 control:= calendar;

when 130 => -- #line 534
 control := progress;
          Control_Direction := Horizontal;

when 136 => -- #line 543
 control:= track_bar;
          Trackbar_Control_Ticks:= No_Ticks;
          Control_Direction := Horizontal;

when 137 => -- #line 547
 control:= up_down;
          Control_Direction := Vertical;

when 146 => -- #line 559
 control := list_view;

when 150 => -- #line 566
 control:= static;

when 151 => -- #line 570
 control:= static;

when 152 => -- #line 573
 control := tab_control;

when 153 => -- #line 576
 control := tree_view;

when 161 => -- #line 589
 Control_Direction:= Vertical;

when 162 => -- #line 590
 style_switch(smooth) := True;

when 163 => -- #line 591
 Control_Direction := Vertical;

when 164 => -- #line 592
 Trackbar_Control_Ticks := Top_Ticks;

when 165 => -- #line 593
 Trackbar_Control_Ticks := Bottom_Ticks;

when 168 => -- #line 597
style_switch(tips) := True;

when 170 => -- #line 599
Control_Direction := Horizontal;

when 171 => -- #line 600
style_switch(keys)     := True;

when 172 => -- #line 601
style_switch (wrap)    := True;

when 173 => -- #line 602
style_switch (no_1000) := True;

when 178 => -- #line 607
 lv_align := GWindows.Common_Controls.Align_Left;

when 180 => -- #line 609
 lv_type := GWindows.Common_Controls.Icon_View;

when 181 => -- #line 610
 lv_type := GWindows.Common_Controls.Small_Icon_View;

when 182 => -- #line 611
 lv_type := GWindows.Common_Controls.List_View;

when 183 => -- #line 612
 lv_type := GWindows.Common_Controls.Report_View;

when 185 => -- #line 614
 lv_sort := GWindows.Common_Controls.Sort_Ascending;

when 186 => -- #line 615
 lv_sort := GWindows.Common_Controls.Sort_Descending;

when 187 => -- #line 616
 lv_auto_arrange := True;

when 191 => -- #line 620
lv_select := GWindows.Common_Controls.Single;

when 193 => -- #line 622
style_switch (tips):= True;

when 195 => -- #line 624
style_switch (has_lines):= True;

when 197 => -- #line 626
style_switch (has_buttons):= True;

when 198 => -- #line 627
style_switch (lines_at_root):= True;

when 202 => -- #line 631
style_switch (single_expand):= True;

when 213 => -- #line 642
style_switch (read_only):= True;

when 222 => -- #line 668
 style_switch (fully_sunken) := True;

when 223 => -- #line 669
 style_switch (half_sunken)  := True;

when 239 => -- #line 691
style_switch(half_sunken) := True;

when 241 => -- #line 693
style_switch(center_image):= True;

when 242 => -- #line 694
control := bitmap;

when 243 => -- #line 695
control := icon;

when 244 => -- #line 696
style_switch(real_size_image) := True;

when 249 => -- #line 701
style_switch (right_justify) := True;

when 253 => -- #line 705
style_switch (whiterect) := True;

when 259 => -- #line 719
  --  By default in GWindows (and elsewhere), edit boxes have borders.
               --  ResEdit adds the style NOT WS_BORDER to hide the border.
               style_switch (simple_border) := True;

when 260 => -- #line 727
Ada_edit_control;

when 271 => -- #line 754
style_switch (multi_line)    := True;

when 272 => -- #line 755
style_switch (read_only)     := True;

when 273 => -- #line 756
style_switch (auto_h_scroll) := True;

when 274 => -- #line 757
style_switch (auto_v_scroll) := True;

when 284 => -- #line 773
 Ada_label_control;

when 285 => -- #line 776
last_alignment := GWindows.Static_Controls.Left;

when 286 => -- #line 777
last_alignment := GWindows.Static_Controls.Center;

when 287 => -- #line 778
last_alignment := GWindows.Static_Controls.Right;

when 288 => -- #line 786
 combo:= no_drop;

when 289 => -- #line 789
 Ada_combo_control;

when 297 => -- #line 810
 combo := no_drop;

when 298 => -- #line 811
 combo := drop_down;

when 299 => -- #line 812
 combo := drop_down_list;

when 300 => -- #line 813
 style_switch (sort):= True;

when 307 => -- #line 829

              Ada_Put_Line(to_spec, "    " & S(last_Ada_ident) & ": Group_Box_Type;");
              Ada_Coord_conv(last_rect);
              Ada_Put_Line(to_body,
                "    Create( Window." & S(last_Ada_ident) & ", Window, " &
                S(last_text) & ", x, y, w, h);"
              );

when 315 => -- #line 863
 Ada_list_box_control;

when 322 => -- #line 883
 style_switch(sort) := True;

when 337 => -- #line 907

              style_switch(checkbox):= True;
              Ada_button_control;

when 338 => -- #line 913
 style_switch(auto)   := False;
                 style_switch(state3) := False;

when 339 => -- #line 916
 style_switch(auto)   := False;
                 style_switch(state3) := True;

when 340 => -- #line 919
 style_switch(auto)   := True;
                 style_switch(state3) := False;

when 341 => -- #line 922
 style_switch(auto)   := True;
                 style_switch(state3) := True;

when 342 => -- #line 934

              style_switch (push):= True;
              Ada_button_control;

when 344 => -- #line 942
 style_switch (default) := True;

when 345 => -- #line 953

              style_switch (radio) := True;
              Ada_button_control;

when 347 => -- #line 961
 style_switch(auto) := True;

when 356 => -- #line 988
 style_switch (auto)  := True;
              style_switch (radio) := True;

when 357 => -- #line 991
 style_switch(radio):= True;

when 358 => -- #line 993
 style_switch (state3):= True;

when 359 => -- #line 995
 style_switch (state3) := True;
              style_switch (auto)   := True;

when 360 => -- #line 998
 style_switch (checkbox):= True;

when 361 => -- #line 1000
 style_switch (auto)     := True;
              style_switch (checkbox) := True;

when 362 => -- #line 1003
 style_switch (bitmap):= True;

when 363 => -- #line 1005
 style_switch (icon):= True;

when 364 => -- #line 1007
 style_switch (ownerdraw):= True;

when 373 => -- #line 1017
 style_switch (multi_line):= True;

when 375 => -- #line 1020
 style_switch (push):= True;

when 376 => -- #line 1022
 style_switch (push):= True;
              style_switch (default):= True;

when 380 => -- #line 1028
 style_switch (default):= True;

when 382 => -- #line 1031
 style_switch (default):= True;

when 383 => -- #line 1042

              if style_switch(vertical) then
                Ada_normal_control ("GWindows.Scroll_Bars.Scroll_Bar_Type", ", Vertical");
              else
                Ada_normal_control ("GWindows.Scroll_Bars.Scroll_Bar_Type", ", Horizontal");
              end if;

when 388 => -- #line 1064
style_switch (vertical) := True;

when 391 => -- #line 1075
 last_control_text := U(YYText);

when 392 => -- #line 1079
 Ada_icon_control;

when 395 => -- #line 1090
 Insert_last_symbol;

when 397 => -- #line 1097
 last_text:= U(YYText);

when 399 => -- #line 1102
RC_Help.last_rect.x := YYLVal.intval;

when 400 => -- #line 1104
RC_Help.last_rect.y := YYLVal.intval;

when 401 => -- #line 1106
RC_Help.last_rect.w := YYLVal.intval;

when 402 => -- #line 1108
RC_Help.last_rect.h := YYLVal.intval;

when 403 => -- #line 1116
 if anonymous_item then
           anonymous_menu_counter:=
             anonymous_menu_counter+1;
           last_dialog_ident:= U("Menu_" &
             Trim(Integer'Image(anonymous_menu_counter),both));
         else
           last_dialog_ident:= last_ident;
         end if;

when 404 => -- #line 1127

         Open_if_separate (S(last_dialog_ident));
         Ada_Put_Line (to_spec,
           "  type " & S(last_dialog_ident) &
           "_Type is tagged record"
         );
         menu_popup_counter := 0;
         popup_top := 0;
         Ada_Put_Line (to_spec,
           "    Main: Menu_Type;  --  Root of the whole menu tree"
         );
         Ada_New_Line (to_body);
         Ada_Proc_Menu (
            to_body,
            S(last_dialog_ident) & "_Type"
         );
         Ada_New_Line (to_body);
         Ada_Put_Line (to_body, "  is");
         Ada_Put_Line (to_body, "  begin");
         Ada_Put_Line (to_body, "    New_Menu.Main := Create_Menu;");

when 405 => -- #line 1149
 empty_dialog_record := True;

when 406 => -- #line 1153
 if empty_dialog_record then
           Ada_Put_Line(to_spec, "    null;  --  empty!");
         end if;
         Ada_Put_Line(to_spec,
           "  end record;  --  " & S(last_dialog_ident) & "_Type"
         );
         Ada_New_Line(to_spec);
         Ada_Proc_Menu(
            to_spec,
            S(last_dialog_ident) & "_Type"
         );
         Ada_Put_Line (to_spec, ";");
         Ada_New_Line (to_spec);
         Ada_Put_Line (to_body,
           "  end Create_Full_Menu;  --  For type: " &
           S(last_dialog_ident) & "_Type" );
         Close_if_separate(S(last_dialog_ident));

when 413 => -- #line 1186
empty_dialog_record := False;

when 414 => -- #line 1191
last_popup_title := U(yytext);

when 415 => -- #line 1193

              menu_popup_counter := menu_popup_counter + 1;  --  Another (sub)menu.
              Ada_Put_Line (to_spec,
                "    " &
                Popup_num_to_Ada_ident (menu_popup_counter) &
                " : Menu_Type; "
                & "  --  Popup level:" & Integer'Image (popup_top + 1) &
                "; title: " &
                S (last_popup_title)
              );
              Ada_Put_Line (to_body,
                "    New_Menu." &
                Popup_num_to_Ada_ident (menu_popup_counter) &
                " := Create_Popup;"
              );
              Ada_Put_Line (to_body,
                "    Append_Menu (New_Menu." &
                Popup_num_to_Ada_ident (popup_stack(popup_top)) &
                ", " & S(last_popup_title) &
                ", New_Menu." &
                Popup_num_to_Ada_ident (menu_popup_counter) &
                ");"
              );
              popup_top := popup_top + 1;
              popup_stack (popup_top) := menu_popup_counter;

when 416 => -- #line 1223
popup_top := popup_top - 1;

when 417 => -- #line 1229

              style_switch := (others => False);  --  Reset all style switches
              append_item_cmd := To_Unbounded_String (
                "    Append_Item (New_Menu." &
                Popup_num_to_Ada_ident (popup_stack (popup_top)) &
                ", " & Replace_special_characters (yytext));

when 418 => -- #line 1238

              Insert_last_symbol;
              append_item_cmd := append_item_cmd & ", " & S(last_Ada_constant) & ");";
              if S(last_Ada_constant) = "0" then
                Ada_Put_Line(to_body,
                  "    --  Constraint error would be raised on line after next, but better having an explanation...");
                Ada_Put_Line(to_body,
                  "    raise Constraint_Error with ""Forgot to set a command for menu item, value 0"";");
              end if;
              Ada_Put_Line(to_body, To_String (append_item_cmd));

when 419 => -- #line 1250

              if style_switch (grayed) then
                Ada_Put_Line(to_body, "    State (New_Menu." &
                Popup_num_to_Ada_ident(popup_stack(popup_top)) &
                ", Command, " & S(last_Ada_constant) &
                ", Grayed);");
              end if;
              if style_switch (inactive) then
                Ada_Put_Line(to_body, "    State (New_Menu." &
                Popup_num_to_Ada_ident(popup_stack(popup_top)) &
                ", Command, " & S(last_Ada_constant) &
                ", Disabled);");
              end if;
              if style_switch (checked) then
                Ada_Put_Line(to_body, "    Check (New_Menu." &
                Popup_num_to_Ada_ident(popup_stack(popup_top)) &
                ", Command, " & S(last_Ada_constant) &
                ", True);");
              end if;

when 426 => -- #line 1283
style_switch (grayed)   := True;

when 427 => -- #line 1284
style_switch (inactive) := True;

when 428 => -- #line 1285
style_switch (checked)  := True;

when 432 => -- #line 1294

              Ada_Put_Line (to_body,
                "    Append_Separator (New_Menu." &
                Popup_num_to_Ada_ident (popup_stack (popup_top)) &
                ");"
              );

when 460 => -- #line 1381

                 Open_if_separate("Version_info", with_body => False);
                 if not separate_items then
                   Ada_Put_Line(to_spec, "  package Version_info is");
                 end if;

when 461 => -- #line 1389
 if not separate_items then
                   Ada_Put_Line(to_spec, "  end Version_info;");
                 end if;
                 Close_if_separate("Version_info", with_body => False);

when 480 => -- #line 1438
RC_Help.version_info_value_counter:= 0;

when 485 => -- #line 1453
RC_Help.version_info_value_counter:= RC_Help.version_info_value_counter + 1;
              case RC_Help.version_info_value_counter is
                when 1 =>
                  declare
                    item: constant String:= yytext;
                  begin
                    Ada_Put(to_spec, "    " & item(item'First+1..item'Last-1));
                  end;
                when 2 =>
                  Ada_Put_Line(to_spec, ": constant String:= " & yytext & ';');
                when others =>
                  null;
              end case;

when 486 => -- #line 1467
RC_Help.version_info_value_counter:= RC_Help.version_info_value_counter + 1;
              case RC_Help.version_info_value_counter is
                when 1 =>
                  null; -- should not happen...
                when 2 =>
                  Ada_Put_Line(to_spec, ": constant:=" & Long_Long_Integer'Image(YYLVal.intval) & ';');
                when others =>
                  null;
              end case;

when 500 => -- #line 1536
Treat_include(yytext(2..yylength-1));

when 507 => -- #line 1561
Treat_include(yytext(2..yylength-1));

when 508 => -- #line 1564
Treat_include(yytext(2..yylength-1));

when 529 => -- #line 1632
 last_ident:= U (YYText);
             last_Ada_constant:= Ada_ify (YYText);
             last_Ada_ident:= last_Ada_constant;
             -- normally no confusion here (record entry vs int. constant)
             anonymous_item:= False;

when 530 => -- #line 1639
 last_ident:= U (YYText);
             last_Ada_constant:= last_ident;
             if YYLVal.intval < -1 then
               last_Ada_ident:= U ("RC_item_Minus_Invalid" & YYText);
             elsif YYLVal.intval = -1 then
               New_static_item;
               last_Ada_constant:= U ("IDC_STATIC");
             else
               last_Ada_ident:= U ("RC_item_" & YYText);
             end if;
             anonymous_item:= True;

when 531 => -- #line 1652
 last_ident:= U (YYText);
             last_Ada_constant := last_ident;
             New_static_item;
             anonymous_item:= True;

                    when others => null;
                end case;


            -- Pop RHS states and goto next state
            if yy.rule_id < 0 then
              raise Constraint_Error with "yy.rule_id = " & Integer'Image (yy.rule_id) & " < 0";
            end if;
            yy.tos      := yy.tos - rule_length(yy.rule_id) + 1;
            if yy.tos > yy.stack_size then
                Text_IO.Put_Line (" Stack size exceeded on state_stack");
                raise yy_Tokens.Syntax_Error;
            end if;
            yy.state_stack(yy.tos) := goto_state(yy.state_stack(yy.tos-1) ,
                                 Get_LHS_Rule (yy.rule_id));

              yy.value_stack(yy.tos) := yyval;

            if yy.debug then
                reduce_debug(yy.rule_id,
                    goto_state(yy.state_stack(yy.tos - 1),
                               Get_LHS_Rule (yy.rule_id)));
            end if;

        end if;


    end loop;


end YYParse;
