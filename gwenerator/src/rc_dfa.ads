package rc_dfa is
aflex_debug : Boolean := False;
--  Warning: This file is automatically generated by AFLEX.
--           It is useless to modify it. Change the ".Y" & ".L" files instead.

  yytext_ptr : Integer;  --  Points to start of yytext in buffer

  --  yy_ch_buf has to be 2 characters longer than YY_BUF_SIZE because we need
  --  to put in 2 end-of-buffer characters (this is explained where it is
  --  done) at the end of yy_ch_buf

  --  ----------------------------------------------------------------------------
  --  If the buffer size variable YY_READ_BUF_SIZE is too small, then
  --  big comments won't be parsed and the parser stops.
  --  YY_READ_BUF_SIZE should be at least as large as the number of ASCII bytes in
  --  comments that need to be parsed.

  YY_READ_BUF_SIZE : constant Integer :=  75_000;
  --  ----------------------------------------------------------------------------

  YY_BUF_SIZE : constant Integer := YY_READ_BUF_SIZE * 2;  --  Size of input buffer
  type unbounded_character_array is array (Integer range <>) of Character;
  subtype ch_buf_type is unbounded_character_array (0 .. YY_BUF_SIZE + 1);
  yy_ch_buf : ch_buf_type;
yy_cp, yy_bp : Integer;

  --  yy_hold_char holds the character lost when yytext is formed
  yy_hold_char : Character;
  yy_c_buf_p   : Integer;   --  Points to current character in buffer

  function YYText return String;
  function YYLength return Integer;
  procedure YY_DO_BEFORE_ACTION;
  --  These variables are needed between calls to YYLex.
  yy_init  : Boolean := True;  --  Do we need to initialize YYLex?
  yy_start : Integer := 0;     --  Current start state number
  subtype yy_state_type is Integer;
  yy_last_accepting_state : yy_state_type;
  yy_last_accepting_cpos  : Integer;
end rc_dfa;
